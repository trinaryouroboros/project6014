#summary Proposals for a language for describing dialogs
#labels Implementation

= Introduction =

Multiple people have proposed that a language be found or devised that is suited to writing conversations. C is not well suited to this.

Simpler is better.

Proposals may go below.

= Death 999's language =

The syntax is very terse so the author can focus on the text.

== basic structure ==

There are four basic large-scale entities, each declared on a line beginning with its (lowercase, singular) name.

  * Greetings show what they say to you at the beginning of a conversation, then direct you to a node of possible responses.

  * Nodes organize what you can say. They contain options. Once you declare a node, all options are in that node until you declare another one.

  * Options shows what the player-character may say on one line then what the other character would say in response on the rest of the lines, then direct you to a node.

  * Text is used for repeated or conditional phrases. You can put it anywhere, but it's best to put it either at the end or near where it'll be used.


Every node and text has a name. Node names can be nearly anything not containing spaces. Text names should start with a letter, and contain no upper-case letters, arithmetic operators, square brackets. Example: 

<pre>
node main
</pre>

or

<pre>
text get_you_for_this
</pre>

This is so they can be jumped to (for nodes) or called (for text). Options may also have names. Greetings do not get names. At the end of a greeting or option, the last line is a declaration of what node to go to, in the format

<pre>
.foo
</pre>

with foo the name of the node to go to. Text items just end with a line that is a '.' (if you want to have a dialog line that begins with a '.', such as '...',  we'll get to that with display directives)

There are two predefined nodenames 'done' and 'fight' with the obvious meanings.

Very simple example, where they say hello and you can say hello or goodbye, then they say goodbye, then you go back to navigation.

<pre>
greeting
hello // I didn't mention this, but '//' can be used for comments
  .main     // leading and trailing whitespace are ignored.
// You can use an indenting convention if you like, as shown below.
// I don't. I just use blank lines to keep things organized.

node main
option
  hello
  goodbye
  .done

option
  goodbye
  goodbye

// you CAN but probably shouldn't have blank lines in the middle of your statements.
// If I write a validation utility, that will definitely give a warning.
  .done
</pre>

== Conditions and Consequences ==

Any of these items -- greeting, node, option, or text -- may have _conditions_ and _consequences_, which are listed on the same line, delimited by spaces. The conditions and consequences are indicated by single-character symbol followed by a _key_. The simplest keys are just names of _flags_, which can be _set_ (interpreted as 'true') or _unset_ (interpreted as 'false').

If all of an item's conditions are met, it can be used. If an item is being sought _by name_ and does not meet the conditions, the search goes on for another item of the same name. For greetings, the first greeting with all of its conditions met is used. All unnamed options with their criteria met are shown. If an option is given a name, only the first option with that name with its conditions met will be shown, just as with nodes and texts (useful for presenting variations on the same option - different responses to the same statement, say).

If an item is actually used (its conditions are met, and for options, the player also selects it), then the consequences are applied. Any consequences on a node itself are applied before the option list is generated.

This example represents the basic conditions and consequences.

<pre>
option =requiredToBeTrue !requiredToBeFalse +setThis -unsetThis
</pre>
To be explicit, if the 'requiredToBeTrue' flag is not set, this option will not appear. If the 'requiredToBeFalse' flag is set, this option will not appear. Otherwise, it will appear. If this option is chosen by the player, the flag 'setThis' is set, and the flag 'unsetThis' is unset.

Here is a longer example illustrating the use of named conditions.

<pre>
node main
option juggling =EXPERT_JUGGLER
Can I show off my juggling talents?
Certainly!
.juggling

option juggling
I don't know anything about juggling. Can you help me?
Not really, sorry.
.main
</pre>
The named option with no condition guarantees that it is complementary to the first. You will be able to say something about juggling. Also, again, it helps avoid errors - less typing out of explicit conditions, and a validator can check for option names that are used only once (you probably didn't mean that).

Using a catch-all is important! If no greeting, node, or option can be found for which the conditions are met, so that literally nothing happens next, this is an _improper condition_, it will result in conversation termination and an entry in the error log.
 

As shortcuts and again to minimize the opportunity for errors, there are three compound operations. Each pair of lines is equivalent:

<pre>
option >foo // think 'arrow of time leads to this'. Only applies if not already true, then it becomes so.
option !foo +foo

option <foo // think 'eat this'. Only applies if already true, then it isn't anymore.
option =foo -foo
</pre>

This is commonly used to close off an option so you can't take it over and over again in the same conversation. To reuse a line from above (and get rid of the things that made it complex before):

<pre>
option >ta_juggling // 'ta_' is an abbreviation I use for 'talked about'
I don't know anything about juggling. Can you help me?
Not really, sorry.
.main
</pre>


The last symbol is the toggle, ~. It is just a consequence, not also a condition. If the consequence is fulfilled, it first checks the key. If the key evaluates as true, it unsets the key. If the key evaluates as false, it sets it. I wouldn't normally be so pedantic (yes, even I have limits), but this means that the toggle actually has a meaning for numeric flags.

<pre>
text ~Switch_on
Okay, I hit the switch. Now what?
.
</pre>

=== keys ===

As mentioned, the keys referred to in conditions and consequences can be just flags. They are interpreted that way if they begin with letters, numbers, or any non-reserved punctuation like <pre>_</pre>, quotes, periods and commas, @, etc..

  * All-lower-case flags will automatically be unset at the end of the conversation - they have 'temporary' scope.
  * All-upper-case flags are global, shared by all dialogs and the game as a whole.
  * Mixed-case flags are preserved but namespaced to this dialog file so you don't collide with the flags other people are using for their races.
  * The flag with the empty string as its name is always TRUE.

Examples:
<pre>
>said_hi // use this to avoid letting the player say hi more than once per conversation
// (it starts unset, thus satisfying the condition, but once taken, sets it, so it won't appear anymore).

>Mentioned_Kohr-Ah // These folks will remember that the player mentioned the Kohr-Ah,
// but other folks in other conversation documents won't

=SHIP_IS_MK_II // If the player upgraded, this will be set
</pre>

=== numeric flags ===

Some other keys refer to numeric flags. These begin with the number sign # and are then followed by an algebraic statement (equality, inequality). For instance,
<pre>
=#BioData>99
</pre>

If it's being used as a *condition*, it evaluates the two sides of the statement and sees whether it's true or not. For example, the condition above will be met if the `BioData` numeric flag has been set to at least 100. Unset numeric flags are treated as 0. All math is integer (this is a change from earlier specification).

If a numeric *consequence* other than '-' is applied, then the left hand side of the statement must be a numeric flag, which will be set to the value of the other side if it's =, or to the nearest satisfying value if it's an inequality.

If the unset consequence '-' is applied, then you may (and probably should) leave off the comparator and right hand side.

Some flags and numeric flags will manipulated by non-dialog elements of the game, and some of those cannot be set directly, like FREE_CARGO_CAPACITY, if there is such a thing. A list of these will eventually be placed here.

=== Arithmetic ===

Numbers need not be literal - you can evaluate numeric flags and evaluate expressions

The arithmetic operators available are, in order by increasing precedence:

  # +, - 
  # /
  # `*`
  # ^, √ (√ is always a binary operator. '2' is not assumed)

The order of operations is RIGHT to LEFT.

 {{{a*b/c*d}}} is just what it looks like - d is in the denominator, not the numerator, because `*` binds more tightly than /. This choice was made so the trimming-to-integer is minimally invasive - numbers are made as large as possible before they get divided.

The radical and exponent operators are arranged as you'd expect, looking at them - and they put the base on opposite sides. So,  {{{ a√b^c }}} is what we'd normally call {{{ b^[c/a] }}}, except that c/a would be trimmed to an integer if you did it that way. Note that doing things right-to-left helps here so the exponentiation acts before the radical, without having to use grouping.

Speaking of which, use square brackets for grouping, like {{{ =#2√[[MAP_X-500]^2+[MAP_Y-500]^2]<10 }}}. This condition is satisfied if you're within 10 units of the center of the map, not inclusive. (if you want to make it inclusive, use '!' and '>' instead of '=' and '<' ). Parentheses are ignored so you can treat them as regular text without having to worry about it being script-language syntax.

You may be tempted to put spaces in your expressions. Don't. It'll mess up the parser. Sorry.


=== random flag ===

There's a special random numeric flag which is a randomly determined number from 0 to 99. It is not rerolled when you evaluate it, but only at the beginning of the conversation and if you try to set it or unset it. The name of this flag is, simply, %.

<pre>
 text blah <#%<25 // this meets the condition 1/4 of the time
BLAH!!!
.

text blah <#%<50 // this also meets the condition 1/4 of the time
//because it won't be taken if the first one was because it's named blah like the first one
blah
.

text blah -#% // this meets the implicit condition half the time
buh
.
</pre>
Note that instead of using the = condition, the < condition was used to require it... and then try to unset it, so the random number would be changed. Also note, the unconditional last option also rerolls the random number.

== Evaluations and Calling Text Items ==

If you want to have the text be dynamic, use square brackets {{{ [foo] }}}. These evaluations can be put in dialog, conditions, or consequences (but not replacing the leading character of a condition or consequence - that has to be literal). Within each replacement, it goes down the list, looking for things to do.

 # find any arithmetic operations, then evaluate numeric parameters on either side and performing the arithmetic. NOTE:  see above in numeric flags about arithmetic and order of operations.
 # substitute text items with the named key. If the key is found but conditions are not met, that's treated as a match yielding the empty string, not a failure to match.
 # substitute the value of any numeric flag with that key, or 0 if none.

If the text item is called from one of the Captain's lines (the first text line of each option), only the first line of the text item will be used.

Parentheses are ignored by this language, as they are too frequently used in dialogue for anyone to want to have to think about whether they're going to cause trouble.

Example:

<pre>
greeting
Greetings, captain! You have [Credits] credits.
.main
</pre>

Here's a somewhat more canny version of the above using text items with conditions. Note that the last text item has no condition, being implicitly conditional on having been reached.

<pre>
greeting
Greetings, captain! You have [credits].
.main

text credits =#Credits=0
no credits
.

text credits =#Credits=1
one credit
.

text credits
[Credits] credits
.
</pre>

If you call a text and the key is found but none of them have the conditions met, then it just uses the empty string (and if it was alone on its line, it moves immediately to the next line as if the line were always blank). Only if no text items are found with that key at all, does it try to evaluate it as a numeric flag.

This can be especially handy for doing conditional processing without changing what's going on - initializing flags, say, so their sense is more convenient throughout.
 
An init example fragment
<pre>// The wiki's acting wonky here. Need to use extra-wide spacing, sorry.

 greeting !Know_You_Well 

 [init] 

 Greetings, unknown starship.

 .main

 text init >First_Contact +Need_Food +Need_Shelter +Need_Water

.</pre>


The second time you meet them, if they still don't know you well yet, the Need_X flags aren't set again even though the dialog they're a consequence of was taken.

Outside of this case where the text item is used specifically for its consequences, or to prevent a text item from being repeated, you should avoid putting consequences on text items. It gets messy really fast. I'll spend two paragraphs on how messy it gets, just to warn you off it:

In particular, it will be very rare to want to put consequences on text items that get substituted into the text of a condition, or that get substituted into the Captain's lines, as these will be executed whether or not the conditions are satisfied (the text item resolves when the condition is evaluated) or whether or not the player chooses that line (the text item resolves when the option to say that is displayed to the player). Still could possibly be useful if you're counting up how long the captain has been holding off on saying something. Handle that stuff with rubber gloves.

If you must put consequences in text items... In contrast to the right-to-left arithmetic, evaluations are performed left to right by order of their closing brackets (as a consequence, no evaluation is ever performed with another evaluation still unresolved inside it). However, each condition or consequence is evaluated separately, so square brackets on a later one will not make them be evaluated before an earlier one.


== Display Directives ==

Certain commands can be given to display in a certain way. For instance, display location, or linebreaks you want on a single page.

Some display directives you may want to use will be:
<pre>
{left} I'm Zoq {center} (Fot goes here) {right} I'm Pik
{top left} My lovely captain! {bottom right} Oh, ZEX!
This is the first line of text{br}And this is the second line
{color=FF0000}I'm suddenly talking in red{color}back to default
{(} if you need to use square brackets or curly braces for some reason, this is something like how you will show them. I'll fill it in if asked. {)}
{}... and that empty pair of braces kept the '...' at the beginning of this line from being interpreted as the end of this text.
</pre>

Other special directives are possible for 'dimming the lights'/vfx, or even changing who you're talking to altogether, but they haven't been specified yet. Don't feel constrained by what exists. This language is in development. If you need it, ask for it.

== Example dialog ==

Here's the moderately complicated dialog I presented in the email where I first mentioned it, slightly modified to take full advantage of the language features.

<pre>
greeting !#Rep<0
Hello, captain!
.main

greeting
Captain, you denied us slug repellent when we needed it.
DIE!
.fight


node main
option hi >said_hi !SLUGS_DEFEATED
Why hello yourself!
I'm so glad you came, captain!
We've come under attack by vicious slugs!
.slugs

option hi >said_hi // implicitly =SLUGS_DEFEATED due to also being a 'hi' option.
Why hello yourself!
It's so nice to see you again, captain
especially since you helped us with our slug infestation!
.main

option bye =said_hi
goodbye
Return soon, captain
.done

option bye // implicitly !said_hi, by virtue of also being a 'bye' option
Actually, I just dropped by for a moment...
Oh, how disappointing!
.done

node slugs
option <HAVE_SLUG_REPELLENT +SLUGS_DEFEATED +#Rep=1
Oh, here, have our slug repellent!
Thank you for your generosity, captain!
.main

option =HAVE_SLUG_REPELLENT +#Rep=-1
Even though we have slug repellent, you can't have any!
You fiend!
.fight

option <try_shoot
Did you try shooting them?
[no_work] // call a text item.
.slugs

option ~BLUE_SWITCH_SET
Try hitting the big blue switch over there.
Umm, okay?
[no_work] // reuse same text item.
.slugs

option
I'm sorry, I'm out of ideas.
That's unfortunate, but we understand.
.main


text no_work >already_took_advice
We tried that.
It didn't work.
.

text no_work // second and later times this is called in one conversation, get this.
We tried that.
It didn't work.
Again.
.
</pre>